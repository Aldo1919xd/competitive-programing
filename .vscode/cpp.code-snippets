{
    "CP Template": {
        "prefix": "plantilla",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "using ll = long long;",
            "using vi = vector<int>;",
            "using vll = vector<ll>;",
            "using pii = pair<int, int>;",
            "",
            "const int INF = 1e9;",
            "const ll LINF = 1e18;",
            "const int MOD = 1e9 + 7;",
            "const double EPS = 1e-9;",
            "",
            "#define all(x) (x).begin(), (x).end()",
            "#define sz(x) (int)(x).size()",
            "#define pb push_back",
            "#define F first",
            "#define S second",
            "",
            "void solve() {",
            "    $0",
            "}",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    int t = 1;",
            "    cin >> t;",
            "    while (t--) solve();",
            "    return 0;",
            "}"
        ],
        "description": "Standard Competitive Programming Template "
    },
    "Modular Exponentiation": {
        "prefix": "modpow",
        "body": [
            "ll modpow(ll base, ll exp, ll mod = MOD) {",
            "    ll res = 1;",
            "    base %= mod;",
            "    while (exp > 0) {",
            "        if (exp & 1) res = (res * base) % mod;",
            "        base = (base * base) % mod;",
            "        exp >>= 1;",
            "    }",
            "    return res;",
            "}",
            "ll modinv(ll n, ll mod = MOD) {",
            "    return modpow(n, mod - 2, mod);",
            "}"
        ],
        "description": "Calculate (base^exp) % mod in O(log exp). Requires prime MOD."
    },
    
"sieve function": {
  "prefix": "sieve",
  "body": [
    "vector<int> sieve(int n) {",
    "    vector<bool> is_prime(n+1, true);",
    "    is_prime[0] = is_prime[1] = false;",
    "    for (int i = 2; i * i <= n; i++) if (is_prime[i])",
    "        for (int j = i * i; j <= n; j += i)",
    "            is_prime[j] = false;",
    "    vector<int> primes;",
    "    for (int i = 2; i <= n; i++) if (is_prime[i]) primes.push_back(i);",
    "    return primes;",
    "}"
  ],
  "description": "Sieve of Eratosthenes"
}
,
    "Sieve SPF (Fast Factorization & Divisors)": {
        "prefix": "sieve_spf",
        "body": [
            "const int MAX_SPF = 1000005;",
            "int spf[MAX_SPF];",
            "",
            "void sieve() {",
            "    iota(spf, spf + MAX_SPF, 0);",
            "    for (int i = 2; i * i < MAX_SPF; i++) {",
            "        if (spf[i] == i) {",
            "            for (int j = i * i; j < MAX_SPF; j += i)",
            "                if (spf[j] == j) spf[j] = i;",
            "        }",
            "    }",
            "}",
            "",
            "vector<int> get_factors(int n) {",
            "    vector<int> factors;",
            "    while (n > 1) {",
            "        factors.push_back(spf[n]);",
            "        n /= spf[n];",
            "    }",
            "    return factors;",
            "}",
            "",
            "vector<int> get_divisors(int n) {",
            "    vector<int> divs = {1};",
            "    while (n > 1) {",
            "        int p = spf[n], count = 0;",
            "        while (n % p == 0) { n /= p; count++; }",
            "        int sz = divs.size();",
            "        for (int i = 0; i < sz; i++) {",
            "            int current = divs[i];",
            "            for (int c = 0; c < count; c++) {",
            "                current *= p;",
            "                divs.push_back(current);",
            "            }",
            "        }",
            "    }",
            "    return divs;",
            "}"
        ],
        "description": "Complete SPF Kit: Sieve, Factorization O(log N), Divisors O(prod(counts))"
    },
    "Math: Get Divisors (O(sqrt N))": {
        "prefix": "get_divisors_sqrt",
        "body": [
            "vector<ll> get_divisors(ll n) {",
            "    vector<ll> divs;",
            "    for (ll i = 1; i * i <= n; i++) {",
            "        if (n % i == 0) {",
            "            divs.push_back(i);",
            "            if (i * i != n) divs.push_back(n / i);",
            "        }",
            "    }",
            "    sort(divs.begin(), divs.end());",
            "    return divs;",
            "}"
        ],
        "description": "Get all divisors sorted in O(sqrt(N)) - Standalone version"
    },
    "Combinatorics (nCr)": {
        "prefix": "ncr",
        "body": [
            "const int MAX_FACT = 200005;",
            "ll fact[MAX_FACT], invf[MAX_FACT];",
            "",
            "void precompute_factorials() {",
            "    fact[0] = 1;",
            "    for (int i = 1; i < MAX_FACT; i++) fact[i] = (fact[i - 1] * i) % MOD;",
            "    invf[MAX_FACT - 1] = modinv(fact[MAX_FACT - 1]);",
            "    for (int i = MAX_FACT - 2; i >= 0; i--) invf[i] = (invf[i + 1] * (i + 1)) % MOD;",
            "}",
            "",
            "ll nCr(int n, int r) {",
            "    if (r < 0 || r > n) return 0;",
            "    return fact[n] * invf[r] % MOD * invf[n - r] % MOD;",
            "}"
        ],
        "description": "Precompute factorials for nCr queries. Requires modpow."
    },
    "Disjoint Set Union (DSU)": {
        "prefix": "dsu",
        "body": [
            "struct DSU {",
            "    vector<int> parent, size;",
            "    DSU(int n) {",
            "        parent.resize(n + 1);",
            "        iota(parent.begin(), parent.end(), 0);",
            "        size.assign(n + 1, 1);",
            "    }",
            "    int find(int v) {",
            "        if (v == parent[v]) return v;",
            "        return parent[v] = find(parent[v]);",
            "    }",
            "    void unite(int a, int b) {",
            "        a = find(a); b = find(b);",
            "        if (a != b) {",
            "            if (size[a] < size[b]) swap(a, b);",
            "            parent[b] = a;",
            "            size[a] += size[b];",
            "        }",
            "    }",
            "};"
        ],
        "description": "DSU with Path Compression and Union by Size"
    },
    "Fenwick Tree": {
        "prefix": "fenwick",
        "body": [
            "struct Fenwick {",
            "    int n; vector<ll> bit;",
            "    Fenwick(int n) : n(n), bit(n + 1, 0) {}",
            "    void add(int i, ll delta) {",
            "        for (++i; i <= n; i += i & -i) bit[i] += delta;",
            "    }",
            "    ll query(int i) {",
            "        ll sum = 0;",
            "        for (++i; i > 0; i -= i & -i) sum += bit[i];",
            "        return sum;",
            "    }",
            "    ll query(int l, int r) { return query(r) - query(l - 1); }",
            "};"
        ],
        "description": "Fenwick Tree (0-indexed implementation)"
    },
    "Segment Tree (Generic)": {
        "prefix": "segtree",
        "body": [
            "template<class T> struct SegTree {",
            "    int n; vector<T> tree;",
            "    T neutral;",
            "    function<T(T, T)> merge;",
            "",
            "    SegTree(int n, T neutral, function<T(T, T)> merge) : n(n), neutral(neutral), merge(merge) {",
            "        tree.assign(4 * n, neutral);",
            "    }",
            "",
            "    void update(int node, int start, int end, int idx, T val) {",
            "        if (start == end) { tree[node] = val; return; }",
            "        int mid = (start + end) / 2;",
            "        if (idx <= mid) update(2 * node, start, mid, idx, val);",
            "        else update(2 * node + 1, mid + 1, end, idx, val);",
            "        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);",
            "    }",
            "",
            "    T query(int node, int start, int end, int l, int r) {",
            "        if (r < start || end < l) return neutral;",
            "        if (l <= start && end <= r) return tree[node];",
            "        int mid = (start + end) / 2;",
            "        return merge(query(2 * node, start, mid, l, r), query(2 * node + 1, mid + 1, end, l, r));",
            "    }",
            "",
            "    void update(int idx, T val) { update(1, 0, n - 1, idx, val); }",
            "    T query(int l, int r) { return query(1, 0, n - 1, l, r); }",
            "};",
            "// SegTree<ll> st(n, 0, [](ll a, ll b){ return a + b; }); // Sum",
            "// SegTree<ll> st(n, LINF, [](ll a, ll b){ return min(a, b); }); // Min"
        ],
        "description": "Generic Segment Tree (Lambdas for Sum, Min, Max, GCD)"
    },
    "Merge Sort Tree": {
        "prefix": "segmst",
        "body": [
            "struct MergeSortTree {",
            "    int n; vector<vector<int>> tree;",
            "    MergeSortTree(const vector<int>& a) : n(a.size()), tree(4 * n) {",
            "        build(1, 0, n - 1, a);",
            "    }",
            "    void build(int node, int start, int end, const vector<int>& a) {",
            "        if (start == end) { tree[node] = {a[start]}; return; }",
            "        int mid = (start + end) / 2;",
            "        build(2 * node, start, mid, a);",
            "        build(2 * node + 1, mid + 1, end, a);",
            "        merge(all(tree[2 * node]), all(tree[2 * node + 1]), back_inserter(tree[node]));",
            "    }",
            "    int query(int node, int start, int end, int l, int r, int k) {",
            "        if (r < start || end < l) return 0;",
            "        if (l <= start && end <= r) return lower_bound(all(tree[node]), k) - tree[node].begin();",
            "        int mid = (start + end) / 2;",
            "        return query(2 * node, start, mid, l, r, k) + query(2 * node + 1, mid + 1, end, l, r, k);",
            "    }",
            "    int count_less(int l, int r, int k) { return query(1, 0, n - 1, l, r, k); }",
            "};"
        ],
        "description": "Merge Sort Tree: Count elements < K in range [L, R]"
    },
    "Sparse Table (RMQ)": {
        "prefix": "spt",
        "body": [
            "template<class T> struct SparseTable {",
            "    int n, k; vector<vector<T>> st; vector<int> lg;",
            "    SparseTable(const vector<T>& a) : n(a.size()) {",
            "        lg.resize(n + 1); lg[1] = 0;",
            "        for (int i = 2; i <= n; i++) lg[i] = lg[i / 2] + 1;",
            "        k = lg[n];",
            "        st.assign(k + 1, vector<T>(n));",
            "        st[0] = a;",
            "        for (int j = 1; j <= k; j++)",
            "            for (int i = 0; i + (1 << j) <= n; i++)",
            "                st[j][i] = min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);",
            "    }",
            "    T query(int l, int r) {",
            "        int j = lg[r - l + 1];",
            "        return min(st[j][l], st[j][r - (1 << j) + 1]);",
            "    }",
            "};"
        ],
        "description": "Sparse Table for Static RMQ (O(1) query, O(N log N) build)"
    },
    "Graph: Read Adjacency": {
        "prefix": "graph_read",
        "body": [
            "int n, m;",
            "cin >> n >> m;",
            "vector<vector<int>> adj(n + 1);",
            "for (int i = 0; i < m; i++) {",
            "    int u, v;",
            "    cin >> u >> v;",
            "    adj[u].push_back(v);",
            "    adj[v].push_back(u);",
            "}"
        ],
        "description": "Read N, M and build Adj List"
    },
    "Graph: BFS (Distances)": {
        "prefix": "bfs",
        "body": [
            "vector<int> dist(n + 1, -1);",
            "queue<int> q;",
            "",
            "dist[1] = 0;",
            "q.push(1);",
            "",
            "while (!q.empty()) {",
            "    int u = q.front(); q.pop();",
            "    for (int v : adj[u]) {",
            "        if (dist[v] == -1) {",
            "            dist[v] = dist[u] + 1;",
            "            q.push(v);",
            "        }",
            "    }",
            "}"
        ],
        "description": "BFS for Shortest Path (Unweighted)"
    },
    "Graph: BFS 0-1": {
        "prefix": "bfs01",
        "body": [
            "vector<ll> dist(n + 1, LINF);",
            "deque<int> dq;",
            "dist[src] = 0;",
            "dq.push_front(src);",
            "",
            "while (!dq.empty()) {",
            "    int u = dq.front(); dq.pop_front();",
            "    for (auto& edge : adj[u]) {",
            "        int v = edge.first;",
            "        int w = edge.second;",
            "        if (dist[u] + w < dist[v]) {",
            "            dist[v] = dist[u] + w;",
            "            if (w == 0) dq.push_front(v);",
            "            else dq.push_back(v);",
            "        }",
            "    }",
            "}"
        ],
        "description": "0-1 BFS using Deque (Faster than Dijkstra for 0/1 weights)"
    },
    "Graph: DFS (Lambda)": {
        "prefix": "dfs",
        "body": [
            "vector<bool> vis(n + 1, false);",
            "function<void(int)> dfs = [&](int u) {",
            "    vis[u] = true;",
            "    for (int v : adj[u]) {",
            "        if (!vis[v]) {",
            "            dfs(v);",
            "        }",
            "    }",
            "};",
            "dfs(1);"
        ],
        "description": "DFS using Lambda (Safe Scope)"
    },
    "Graph: Dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "vector<ll> dist(n + 1, LINF);",
            "priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;",
            "",
            "dist[src] = 0;",
            "pq.push({0, src});",
            "",
            "while (!pq.empty()) {",
            "    ll d = pq.top().first;",
            "    int u = pq.top().second;",
            "    pq.pop();",
            "",
            "    if (d > dist[u]) continue;",
            "",
            "    for (auto& edge : adj[u]) {",
            "        int v = edge.first;",
            "        ll w = edge.second;",
            "        if (dist[u] + w < dist[v]) {",
            "            dist[v] = dist[u] + w;",
            "            pq.push({dist[v], v});",
            "        }",
            "    }",
            "}"
        ],
        "description": "Dijkstra Algorithm (Weighted Shortest Path)"
    },
    "Graph: LCA (Binary Lifting)": {
        "prefix": "lca",
        "body": [
            "struct LCA {",
            "    int n, LOG; vector<vector<int>> up; vector<int> depth;",
            "    LCA(const vector<vector<int>>& adj, int root = 1) : n(adj.size()) {",
            "        LOG = 32 - __builtin_clz(n);",
            "        up.assign(n, vector<int>(LOG));",
            "        depth.resize(n);",
            "        dfs(root, root, adj);",
            "    }",
            "    void dfs(int u, int p, const vector<vector<int>>& adj) {",
            "        up[u][0] = p;",
            "        for (int i = 1; i < LOG; i++) up[u][i] = up[up[u][i - 1]][i - 1];",
            "        for (int v : adj[u]) {",
            "            if (v != p) {",
            "                depth[v] = depth[u] + 1;",
            "                dfs(v, u, adj);",
            "            }",
            "        }",
            "    }",
            "    int get(int u, int v) {",
            "        if (depth[u] < depth[v]) swap(u, v);",
            "        for (int i = LOG - 1; i >= 0; i--) {",
            "            if (depth[u] - (1 << i) >= depth[v]) u = up[u][i];",
            "        }",
            "        if (u == v) return u;",
            "        for (int i = LOG - 1; i >= 0; i--) {",
            "            if (up[u][i] != up[v][i]) {",
            "                u = up[u][i]; v = up[v][i];",
            "            }",
            "        }",
            "        return up[u][0];",
            "    }",
            "    int dist(int u, int v) { return depth[u] + depth[v] - 2 * depth[get(u, v)]; }",
            "};"
        ],
        "description": "LCA using Binary Lifting (Encapsulated, No Macros)"
    },
    "Geometry: Point Struct": {
        "prefix": "geo_point",
        "body": [
            "struct P {",
            "    ll x, y;",
            "    bool operator<(const P &o) const {",
            "        return x < o.x || (x == o.x && y < o.y);",
            "    }",
            "    bool operator==(const P &o) const {",
            "        return x == o.x && y == o.y;",
            "    }",
            "    P operator-(const P &o) const {",
            "        return {x - o.x, y - o.y};",
            "    }",
            "};",
            "",
            "ll cross_product(P a, P b, P c) {",
            "    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);",
            "}"
        ],
        "description": "2D Point Structure with Cross Product (Long Long)"
    },
    "Geometry: Convex Hull (Monotone Chain)": {
        "prefix": "convex_hull",
        "body": [
            "// Requires struct P and cross_product",
            "vector<P> convex_hull(vector<P> &pts) {",
            "    int n = pts.size(), k = 0;",
            "    if (n <= 2) return pts;",
            "    vector<P> h(2 * n);",
            "    sort(pts.begin(), pts.end());",
            "    // Lower hull",
            "    for (int i = 0; i < n; ++i) {",
            "        while (k >= 2 && cross_product(h[k - 2], h[k - 1], pts[i]) <= 0) k--;",
            "        h[k++] = pts[i];",
            "    }",
            "    // Upper hull",
            "    for (int i = n - 2, t = k + 1; i >= 0; i--) {",
            "        while (k >= t && cross_product(h[k - 2], h[k - 1], pts[i]) <= 0) k--;",
            "        h[k++] = pts[i];",
            "    }",
            "    h.resize(k - 1);",
            "    return h;",
            "}"
        ],
        "description": "Convex Hull (Monotone Chain). change colineal  '< 0 '."
    },
    "String: KMP": {
        "prefix": "kmp",
        "body": [
            "vector<int> prefix_function(const string& s) {",
            "    int n = s.length();",
            "    vector<int> pi(n);",
            "    for (int i = 1; i < n; i++) {",
            "        int j = pi[i - 1];",
            "        while (j > 0 && s[i] != s[j]) j = pi[j - 1];",
            "        if (s[i] == s[j]) j++;",
            "        pi[i] = j;",
            "    }",
            "    return pi;",
            "}"
        ],
        "description": "KMP Prefix Function (Pi Array)"
    },
    "String: Z-Function": {
        "prefix": "zfunc",
        "body": [
            "vector<int> z_function(const string& s) {",
            "    int n = s.length();",
            "    vector<int> z(n);",
            "    for (int i = 1, l = 0, r = 0; i < n; ++i) {",
            "        if (i <= r) z[i] = min(r - i + 1, z[i - l]);",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];",
            "        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Z-Function Algorithm"
    }
}